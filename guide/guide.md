# [이론] Git/GitHub이란?

> **여기서 잠깐!✋**
>
> 이 문서는 다양한 사용 경험을 갖춘 사람을 대상으로 하여, 초심자분들이 처음 접했을 때는 조금 어려우실 수도 있습니다.
>
> 1. Git/GitHub에 대해 처음 들어보셨다면?
>    - 자주 사용하는 Git 명령어 위주로 알아보기
> 2. 난 Git/GitHub 좀 써봤다면?
>    - 모든 내용을 다 이해해보기
>
> 다들 처음 Git/GitHub을 접했을 때 어려운 것은 당연해요! 두려워하지 말고 Git/GitHub을 도전해보아요.



**목차 구성**

- [Git/GitHub이란?](#Git/GitHub이란?)
- [주요 용어와 개념](#주요-용어와-개념)
- [시작하기](#시작하기)
- [Git 브랜치](#Git-브랜치)
- [Git 명령어](#Git-명령어)
- [Git Merge](#Git-Merge)
- [Git Rebase](#Git-Rebase)



## Git/GitHub이란?

- Git: 버전관리 시스템(프로그램)
- GitHub: 원격저장소, 서버(클라우드)

### Git

Git은 소스코드를 효과적으로 관리하기 위해 개발된 **분산형 버전 관리 시스템(Distributed Version Control)**입니다.

버전 관리 시스템은 왜 필요할까요? 만약 버전관리시스템이 없다면 폴더별로 버전의 이름을 붙여서 하나씩 관리하는 경우가 많았습니다. 마치 저희가 작업 폴더를 `최종`,` 최_최종`,`정말_최종` 이렇게 관리하는 것처럼요! 만약 그렇게한다면 불편한 점들이 생기겠죠? 



그래서 등장한 것이...

**Centralized Version Control**입니다.

**서버**에서 히스토리를 관리해서 각 개발자들이 원하는 내용을 업데이트하여 즉각적으로 동기화하는 시스템이죠. 하지만 서버에 문제가 생긴다면 많은 개발자들이 서버에 있는 내용을 확인할 수 없어 일을 못하는 단점이 있습니다.

이 단점을 개선한 것이...

**Distributed Version Control**입니다.

서버에만 히스토리가 있는 것이 아니라 모든 개발자들이 동일한 히스토리를 갖도록 하는거죠. 만약 서버에 문제가 생겨도 각각의 개발자들이 동일한 히스토리를 가지고 있기 때문에, 작업을 이어갈 수 있습니다. 

이러한 서버를 제공해주는 서비스로 [GitHub](https://github.com/)과 [Bitbucket](https://bitbucket.org/)과 같은 클라우드가 있습니다.

<details>
<summary>Git은 어떻게 만들어졌을까요?</summary>
<div markdown="1">
리눅스 창시자 Linux Torvalds는 CVS(Cen)  
</div>
</details>

  

  

  


  리눅스 창시자 Linus Torvalds는 CVS(Cen)

- 기존의 버리 관리시스템은 델타 베이스
- hello 
</details>  



### GitHub



그럼 Git과 GitHub을 왜 사용할까요?

-  가장 대중적이며 많이 사용됩니다.
- 오픈소스이므로 무료입니다.
- 모든 종작이 빠릅니다.
- 오프라인으로 사용할 수 있습니다.
- 실수를 고치기가 쉽습니다.
- 각 기능별 브랜치로 쉽고 빠르게 협업 효율을 높일 수 있습니다.



## 주요 용어와 개념

Git/GitHub을 본격적으로 사용해보기 전에 Git의 저장공간인 Working Directory, Stage Area, Repository를 공부해봅시다.

Git은 파일의 변경 사항을 크게 3가지로 구분하여 관리합니다.

- Working Directory: 작업하고 있는 프로젝트 디렉토리
- Stage Area: 커밋을 하기 위해 `git add` 명령어로 추가한 파일들이 모여있는 공간
- Repository: 커밋들이 모여있는 저장소

/* 이미지 추가 - Working Directory, Stage Area, Repository*/

**Working Directory**

작업 폴더로 Git으로 관리할 프로그램의 소스나 파일들이 위치하는 공간입니다. `git init` 명령을 이용해 초기화 작업을 실행하면 Repository가 생성됩니다.

/*Initialize 이미지 추가 */

**Repository**

소스나 파일들의 저장소입니다. Working Directory에서 이루어지는 모든 작업 정보가 저장되는 곳입니다. Repository 저장소에 있는 정보들은 Working Directory 내에 `.git` 폴더안에서 관리됩니다.

Git은 **local Repository**, **remote Repository** 두 종류의 저장소로 구분됩니다.

/* 로컬 저장소와 원격 저장소 이미지 */

- 로컬 저장소(Local Repository)

  **내 PC**에 파일이 저장되는 개인 전용 저장소입니다.

- 원격 저장소(Remote Repository)

  파일이 **원격 저장소 전용 서버**에서 관리되며 여러 사람과 공유하기 위한 저장소입니다.

자신의 PC 저장소에서 작업하다가 작업한 내용을 공유하고 싶을 때 원격 저장소에 업로드하면 되겠죠? 물론 원격 저장소에서 다른 사람이 파일을 로컬 저장소로 가져올 수도 있습니다.



## 시작하기

이제 Git을 본격적으로 사용해봅시다.

### Git 설치

### Git 설치

Git을 사용하려면 자신의 컴퓨터에 `git`을 설치해야 합니다. https://git-scm.com/ 에 접속하여 자신이 사용하는 운영체제에 맞는 설치파일을 다운로드합니다.

Git을 비롯해 최근 개발에 많이 사용되는 방식은 CLI(Command Line Interface)를 사용하는 것입니다.

즉, 윈도우의 [GUI(Graphic User Interface)](https://ko.wikipedia.org/wiki/%EA%B7%B8%EB%9E%98%ED%94%BD_%EC%82%AC%EC%9A%A9%EC%9E%90_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4) 환경이 아니라 Terminal 혹은 cmd와 같은 콘솔 화면에서 텍스트를 직접 타이핑해서 작업하는 방식을 말합니다.

- Windows는 Git bash를, Mac은 터미널을 사용합니다.

  

### 환경 설정

처음 git을 사용할 때 사용자 이름과 email 주소를 지정해야 합니다.

```bash
git config --global user.name "이름"
git config --global user.email "이메일주소"
```



### Repository 생성

#### Local Repository 생성

작업 디렉토리를 생성하고 git repository로 사용하도록 초기화 작업을 진행합니다. 작업 디렉토리는 사용자의 홈디렉토리나 별도로 관리하는 경로에 저장소를 만들고 시작합니다.

```bash
mkdir test	# mkdir: make_directory, test 디렉토리를 생성한다.
cd test			# cd: change_directory, test 디렉토리로 이동한다.
git init		# 작업 디렉토리로 설정한다.
```

/* 이미지 추가*/

#### Remote Repository 생성



#### Remote Repository 연결

앞에서 원격 저장소를 소개했죠? 

우리는 github 서버에 Working Directory에서 작업한 내용을 관리하려고 합니다. 이 작업을 하기 위해서 github에 remote repository를 생성해야 합니다.



## Git 브랜치

Git의 최고 장점이라고 평가되는 브랜치는 무엇일까요?

개발을 하다보면 코드를 여러 개 복사하고 원래 코드와 상관없이 독립적으로 개발을 진행해야 하는 상황이 생길 수 있습니다. 예를들어 현재 개발된 홈페이지에 A와 B가 새로운 기능을 추가하고 싶은 것처럼요!

기본적으로 Git은 `main` 브랜치를 생성합니다. 처음 커밋하면 이 `main` 브랜치는 생성된 커밋을 가리킵니다. 이후 커밋이 생성되면 `main` 브랜치는 자동으로 가장 마지막 커밋을 가리킵니다.

/* 브랜치 커밋 히스토리 이미지 추가 */

HEAD는 특정 브랜치의 마지막 커밋에 대한 포인터를 말합니다. 이 그림에서는 main 브랜치의 마지막 커밋인 `5f832d`를 가리키겠네요!



> **브랜치 생성**

새로운 작업을 하기위해 브랜치를 생성해 봅시다. 생성한 브랜치는 하나의 작업 단위로 가져갈 수 있겠죠?

```bash
git branch {생성할 브랜치 이름}
```

/* 브랜치 생성 이미지 추가 */

새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리키는 것을 확인할 수 있습니다.



> **브랜치 이동**

이제 생성된 브랜치로 이동해볼까요? 

checkout 명령어를 이용해서 현재 작업중인(=HEAD가 가리키는) 브랜치를 이동해봅시다.

```bash
git checkout {이동할 브랜치 이름}
```

/* checkout 브랜치 이미지 추가 */



+) `git checkout -b {브랜치 이름}` 명령어를 사용하면, 브랜치를 생성하고 동시에 이동할 수 있답니다.



### 브랜치는 왜 필요할까요?

여러명이 동시에 개발하는 상황을 떠올려볼까요? 아마 누군가는 '회원 가입'을, 누군가는 '채팅 기능'을 만드는 것으로 역할 분담할 수 있을 것입니다. 여러 명이서 동시에 작업할 때 다른 사람의 작업에 영향을 주거나 받지 않도록 각자 작업 브랜치를 만들고 메인 브랜치에 자신의 변경 사항을 적용합니다.

이렇게 하면 다른 사람의 작업에 영향을 받지 않고 독립된 작업을 수행할 수 있고, 작업이 완료되면 그 결과를 하나로 모을 수 있겠죠. 

이러한 방식으로 작업하면 '작업 단위', 즉 브랜치로 그 작업 기록을 중간 중간 남기게 되므로 문제가 발생했을 때 원인이 되는 작업을 찾고 그에 따른 대책을 쉽게 세울 수 있습니다.

/* 브랜치 필요성 이미지 추가 */

+) 이처럼 브랜치를 생성할 때 규칙을 만들어 효과적으로 협업하는 방법을 [Git 브랜치 전략](https://inpa.tistory.com/entry/GIT-%E2%9A%A1%EF%B8%8F-github-flow-git-flow-%F0%9F%93%88-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EC%A0%84%EB%9E%B5)이라고 합니다.



## Git 명령어

### git init

현재 작업 디렉토리를 git으로 관리하기 위한 명령어입니다.

1. 저장소로 사용하고자 하는 디렉토리로 이동하여 `git init`을 입력합니다.

   ```bash
   git init
   ```

   

2. `.git` 디렉토리가 생성됩니다. Git이 현재 디렉토리의 변동사항을 계속 파악하고 있다는 의미입니다. 

   - `.git` 디렉토리는 숨겨진 디렉토리입니다. 일반적인 `ls` 명령만으로는 디렉토리가 조회되지 않습니다. 따라서 `ls -al` 을 입력하여 확인 가능합니다.

​		/* 이미지 추가 */

### git remote add {등록 이름} {원격 저장소 주소}

`git init` 명령어로 작업 디렉토리에서 git을 사용할 수 있도록 설정했습니다. github을 사용하는 이유가 원격 저장소에 작업 내용을 기록하기 위함이라고 했죠? 그렇기 위해서는 **원격 저장소와 로컬 작업 저장소를 연결**해야 합니다.

```bash
git remote add {등록 이름} {원격 저장소 주소}
```

- 등록 이름: [원격 저장소 주소]의 별명(alias)라고 생각하면 됩니다. 매번 긴 원격 저장소 주소를 입력해야 한다면 매우 귀찮을 거예요. 우리는 관례적으로 원격 저장소의 별명으로 `origin`을 사용한답니다.
  - git clone을 이용하여 프로젝트를 가져올 경우 자동으로 remote 저장소의 이름이 origin으로 등록됩니다.
- 원격 저장소 주소: GitHub repository 주소를 말합니다.



### git clone {원격 저장소 주소} {복제 경로}

GitHub 원격 저장소에 있는 내용들을 로컬에 복제해오는 것을 말합니다.

- 복제 경로(생략 가능): 원격 저장소에 있는 내용들을 로컬에 복제할 경로를 지정하면, 해당 위치에 내용이 복제됩니다.

```bash
git clone {원격 저장소 주소}
```



### git add

작업 디렉토리의 변경 내용을 스테이징 영역에 추가하기 위해 사용하는 명령어입니다. 

스테이징 영역은 변경 사항 중에 '저장하고 싶은 부분만 선택해 임시로 저장'할 수 있는 공간인데요.  이미 로컬 저장소와 원격 저장소가 존재하는데, 왜 별도의 공간이 필요한지 궁금하실 것 같네요. 자세한 내용은 [Git의 Staging Area는 어떤 점이 유용한가](https://blog.npcode.com/2012/10/23/git%EC%9D%98-staging-area%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%9D%B4-%EC%9C%A0%EC%9A%A9%ED%95%9C%EA%B0%80/)에 정리되어 있으니 참고하시면 좋을 것 같습니다~

> 특정 파일만 스테이징 하기(특정 파일의 변경 사항만 스테이징)

```bash
git add {파일명}
```



> 저장소 내 모든 파일 스테이징 하기(모든 파일의 변경 사항을 스테이징)

```bash
git add .
```



### git commit

`add` 명령어로 변경 내용을 스테이징 영역에 추가했습니다. 그럼 이제 추가되었다는 것을 기록해야겠죠?

`commit`은 파일 및 폴더의 추가/변경 사항을 저장소에 기록하는 명령어입니다. 즉 스테이징된 파일을 저장소로 옮기는 작업입니다.

-  `-m` 옵션: `commit` 명령어와 함께 사용하는 옵션입니다. 저장소로 파일을 옮길 때 해당 커밋의 메시지를 작성할 수 있도록 합니다. 메시지는 ""(큰 따옴표) 안에 작성합니다.
- 만약 옵션이 없다면, vim 에디터로 연결되며 한줄로 표현하기 어려운 메시지를 자세하게 설명할 수 있습니다.

```bash
git commit -m "커밋 메시지 내용"
```

커밋 메시지를 작성하는 것은 정말 중요합니다! 마치 역할분담하여 과제할 때, 자신이 맡은 작업물만 달랑 주기보다는 '어떤 작업을 했는지' 설명하는 것처럼요. 그래서 커밋 메시지 규칙도 있답니다.(참고: [How to Wriate a Git Commit Message](https://cbea.ms/git-commit/)) 



### git status

Staged, Unmodified 등 파일들의 상태(status)를 확인하는 명령어입니다.

지금까지 add, commit 명령어를 공부하면서 '스테이징 영역'이라는 단어를 들어봤을 것입니다. 또 '변경 사항을 감지하여 기록한다'는 등 이런 이야기도 들어봤을 것입니다.

이처럼 git으로 관리하는 파일들은 다음의 상태(status)를 갖습니다. 

**[git으로 관리하는 파일 상태]**

- **Untracked**: Git 저장소에 있지만 Git이 관리하지 않는 상태
- **Tracked**: Git이 관리하는 상태
  - **Unmodified**: 파일이 수정되지 않은 상태
  - **Modified**: 파일이 수정된 상태
  - **Staged**: 스테이징 영역(커밋 직전 저장소)에 올라간 상태

만약 1) <u>처음 저장소를 clone</u>해오게 되면, 모든 파일은 **Tracked**이면서 **Unmodified** 상태가 됩니다. 이 상태에서 2) <u>어떤 파일을 수정하면</u> 해당 파일은 **Tracked**이면서 **Modified** 상태가 됩니다. 실제로 3) <u>원격 저장소에 변경 내용을 반영하기 위해서</u> 수정한 파일을 **Staged** 상태로 만들고, Staged 상태의 파일을 **commit**해야 합니다.  

/* 이미지 추가 */

> 변경 사항이 없을 경우

/* 이미지 추가*/

> 변경 사항이 있을 경우

**git add 진행하지 않은 상태**

Untracked 상태임을 확인할 수 있습니다.

/* 이미지 추가 */



**git add 진행 후**

staged(스테이징 됨) 상태가 된 것을 확인할 수 있습니다. 즉 커밋할 준비가 된 상태입니다.

/* 이미지 추가 */



### git branch

위에서 [브랜치](#Git-브랜치)에 대해 공부했죠? 관련 명령어를 알아봅시다.

> 브랜치 생성하기

```bash
git branch {브랜치명}
```

/* 이미지 추가 */



> 브랜치 확인하기

```bash
git branch
```

/* 이미지 추가 */



> 브랜치 삭제하기

```bash
git branch -d {브랜치명}
```

/* 이미지 추가 */



### git checkout

현재 작업중인 브랜치를 가리키는 포인터를 HEAD라고 합니다. 

작업중인 브랜치에서 다른 브랜치로 이동하려면 HEAD를 이동시키면 됩니다. 

> 브랜치 이동하기

```bash
git checkout {브랜치명}
```

/* 이미지 추가 */

기존 main 브랜치에서 /* 변경된 브랜치명*/으로 이동된 것을 확인할 수 있습니다. 

브랜치 이동은 현재 존재하는 브랜치들 중에서 이동할 수 있습니다. 만약 checkout하려는 브랜치가 없다면 이동할 수 없겠죠.



> 브랜치 생성하면서 이동하기

```bash
git checkout -b {브랜치명}
```

/* 이미지 추가 */

/* 브랜치 이름 */가 생성되고 동시에 이동된 모습을 확인할 수 있습니다.



### git pull origin {브랜치명}



### git log



### git diff



### git rm



### git reset {option} {이동하고 싶은 커밋}



## Git Merge



## Git Rebase

